<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Happy 20/10 üíñ</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: url('https://images.unsplash.com/photo-1539593395743-7da5ee10ff07?crop=entropy&cs=srgb&fm=jpg&q=85') center/cover no-repeat;
      height: 100vh;
      width: 100vw;
    }

    .message {
      position: absolute;
      bottom: 60px;
      width: 100%;
      text-align: center;
      font-size: 2rem;
      font-weight: bold;
      color: #ffb6c1;
      text-shadow: 0 0 20px #ff69b4, 0 0 40px #ff1493;
      font-family: 'Segoe UI', cursive;
      animation: glow 3s ease-in-out infinite alternate;
    }

    @keyframes glow {
      from { text-shadow: 0 0 10px #ff69b4, 0 0 20px #ff1493; }
      to { text-shadow: 0 0 30px #ff69b4, 0 0 60px #ff1493; }
    }
  </style>
</head>
<body>
  <div class="message">üíê Ch√∫c b√©iu lu√¥n vui v·∫ª  üíê</div>

  <!-- Three.js Module -->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';

    // ======== C·∫¢NH, CAMERA, RENDERER ========
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // ======== H√åNH TR√ÅI TIM ========
    function heartShape(t) {
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
      return new THREE.Vector3(x, y, 0);
    }

    const heartCount = 10000; // r·∫•t nhi·ªÅu ƒëi·ªÉm
    const heartGeometry = new THREE.BufferGeometry();
    const heartPositions = new Float32Array(heartCount * 3);

    for (let i = 0; i < heartCount; i++) {
      const t = Math.random() * Math.PI * 2;
      const p = heartShape(t);

      // ph√¢n b·ªë ƒë·ªÅu trong tr√°i tim
      const r = Math.cbrt(Math.random());
      p.multiplyScalar(0.15 + r * 0.2);

      // z √≠t kho·∫£ng tr·ªëng h∆°n
      p.z = (Math.random() - 0.5) * 2;

      heartPositions[i*3] = p.x;
      heartPositions[i*3 + 1] = p.y;
      heartPositions[i*3 + 2] = p.z;
    }

    heartGeometry.setAttribute('position', new THREE.BufferAttribute(heartPositions, 3));
    const heartMaterial = new THREE.PointsMaterial({
      color: 0xff69b4,
      size: 0.1,
      transparent: true,
      opacity: 0.9
    });
    const heart = new THREE.Points(heartGeometry, heartMaterial);
    scene.add(heart);

    // ======== SAO N·ªÄN ========
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 5000;
    const starPositions = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount * 3; i++) starPositions[i] = (Math.random() - 0.5) * 200;
    starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    const stars = new THREE.Points(starGeometry, new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.3,
      transparent: true,
      opacity: 0.8
    }));
    scene.add(stars);

    camera.position.z = 12;

    // ======== N·ªû / THU CH·∫¨M ========
    function getHeartScale() {
      return 1 + 0.2 * Math.sin(Date.now() * 0.0015); // c·ª±c ch·∫≠m
    }

    // ======== XOAY KHI K√âO CHU·ªòT ========
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };

    renderer.domElement.addEventListener('mousedown', e => {
      isDragging = true; previousMousePosition = { x: e.clientX, y: e.clientY };
    });
    renderer.domElement.addEventListener('mouseup', e => { isDragging = false; });
    renderer.domElement.addEventListener('mousemove', e => {
      if(isDragging){
        const deltaMove = { x: e.clientX - previousMousePosition.x, y: e.clientY - previousMousePosition.y };
        heart.rotation.y += deltaMove.x * 0.005;
        heart.rotation.x += deltaMove.y * 0.005;
        previousMousePosition = { x: e.clientX, y: e.clientY };
      }
    });

    // ======== ANIMATION LOOP ========
    function animate() {
      requestAnimationFrame(animate);

      const scale = getHeartScale();
      heart.scale.set(scale, scale, scale);

      stars.rotation.y += 0.0005;
      stars.rotation.x += 0.0003;

      renderer.render(scene, camera);
    }
    animate();

    // ======== RESIZE ========
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
  </script>
</body>
</html>
